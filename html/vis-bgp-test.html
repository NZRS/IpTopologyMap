<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head lang="en">
    <meta charset="UTF-8">
    <title>IP Topology Map</title>
    <style type="text/css">
    html, body {
        width: 100%;
        height: 100%;
		background-color: #000;
    }
    #ipvis {
	height: 100%;
	width: 78%;
	background: black;
	margin-left: 22%;
    }
    #legend {
	width: 20%;
	min-height: 85%;
	background: #000;
	color: white;
	padding-left: 1%;
	padding-left: 2%;
	font-size: 13px;
	font-family: Segoe, "Segoe UI", "DejaVu Sans", "Trebuchet MS", Verdana, sans-serif;
	float: left;
	clear: none;
	text-align: left;
    }
    #console {
	float: left;
	background: black;
	color: white;
	font-size: 8;
	min-height: 15%;
	width: 100%;
	font-family: Segoe, "Segoe UI", "DejaVu Sans", "Trebuchet MS", Verdana, sans-serif;
	clear: none;
    }
    #brand-title {
	width: 100%;
	border-bottom: 1px solid #3bb3e9;
	margin-right: 3%;
	font-weight: 600;
	font-size: 18px;
	text-align: center;
	font-family: Segoe, "Segoe UI", "DejaVu Sans", "Trebuchet MS", Verdana, sans-serif;
	float: left;
	clear: none;
	margin-bottom: 6%;
	padding-bottom: 14px;
    }
	a {color:#3bb3e9;}
	h3 {
	    color: #3bb3e9;
	    font-size:19px;
	    border-bottom: 1px solid #3bb3e9;
	    margin-right: 3%;
	    margin-bottom: 10px;
    }
	li:before {
	    padding-right: 3px;
    }
    .path_entry {
        width: 90%;
    }
    .path_label {
        width: 20%;
    }
    </style>
</head>
<body>
    <div id="legend">
        <div style="text-align:center;"><img
                src="/images/NZRS_Logo_white.png" height="100" alt=""/></div>
        <span id="brand-title"><span class="country"></span> IP Topology
            Map</span>
      
<p>  <li>Topology derived from hundreds of ICMP traceroutes,
                originated from the <a href="https://atlas.ripe.net">RIPE
                    ATLAS</a> probes located in <span class="country"></span>
                <ul>
                    <li>To any other RIPE ATLAS probes in <span
                            class="country"></span>
                    <li>To randomly selected IP addresses in <span
                        class="country"></span> visible address space</li>
                    <li>To the Top 100 popular websites in <span
                            class="country"></span> according to Alexa</li>
                </li></ul>
            <li>IP addresses mapped to ASN using MaxMind GeoIP database. AS
        Path derived from IP Path using custom
        <a href="https://github.com/NZRS/IpTopologyMap">code</a></li>
            <li>Country and names for each AS fetched from Team Cymru <a href="http://www.team-cymru.org/IP-ASN-mapping.html">database</a></li>
        </li>
        </p>
        <p>
      <h3>Legend</h3>
      
            <li>Blue: <span id="PriCountry"></span></li>
            <li>Yellow: <span id="SecCountry"></span></li>
            <li>Red: IXs</li>
            <li>Orange: Tier1 AS (according to <a
                    href="http://www.caida.org/data/as-relationships/">CAIDA</a>)</li>
            <li>Green: Other Countries ASNs</li>

        </p>

        <div id="metadata"><h3>Metadata</h3>
            <span id="metadata_text"></span></div>
        <div class="map-ui">
            <h3>Node Search</h3>
            <label for="node-search">Node Search: </label>
            <input id="node-search"/>
        </div>
        <div id="light-path">
            <h3>Path Exploration</h3>
            <div class="path_entry">
                <label class="path_label" for="path_s">Start: </label>
                <select name="path_start" id="path_s">
                    <option disabled selected>Pick Start</option>
                </select>
            </div>
            <div class="path_entry">
                <label class="path_label" for="path_e">End: </label>
                <select name="path_end" id="path_e"></select>
            </div>
        </div>
        <div id="console"><h3>Information</h3><span id="info_window"/></div>
    </div>
    <div id="ipvis"></div>
   

    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.16.1/vis.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css"
          href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.css"/>
    <script
            src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.11.4/jquery-ui.js">
    </script>

    <script type="text/javascript">
        var network;
        var highlightActive = false;
        var hl_edge = false;
        var datafile = 'data/full-network.json';

        $.getJSON(datafile, function(data, status) {
            var nodes = [];
            var edges = [];
            var node_names = [];
            var vis_nodes, vis_edges;
            var metadata, path_sel;

            $.each(data['nodes'], function (i, entry) {
                nodes.push({
                    'id': entry.id,
                    'label': entry.label,
                    'asn': entry.ASN,
                    'group': entry.group,
                    'country': entry.country,
                    'value': entry.value,
                    'x': entry.x_pos,
                    'y': entry.y_pos
                });
                node_names.push({
                    'label': entry.label + "(" + entry.ASN + ")",
                    'value': entry.id
                });
            });

            $.each(data['edges'], function (i, entry) {
                edges.push({
                    'to': entry.to,
                    'from': entry.from,
                    'class': entry.class,
                    'value': entry.value
                });
            });

            metadata = data['metadata'];
            path_sel = data['path-summary'];

            redrawAll();

            function redrawAll() {
                var container = document.getElementById('ipvis');
                vis_edges = new vis.DataSet(edges);
                vis_nodes = new vis.DataSet(nodes);
                var options = {
                    autoResize: true,
                    width: '100%',
                    height: '100%',
                    layout: {
                        randomSeed: 8
                    },
                    nodes: {
                        shape: 'dot',
                        size: 20,
                        physics: false,
                        borderWidth: 0.5,
                        font: {
                            color: 'white',
                            size: 10
                        }
                    },
                    edges: {
                        smooth: {
                            enabled: false
                        },
                        width: 1.5,
                        color: {
                            color: 'rgba(211,211,211,0.1)',
                            highlight: 'rgba(211,211,211,0.6)'
                        }
                    },
                    groups: {
                        PC: {
                            color: {
                                background: 'rgba(255,255,0,0.8)',
                                border: 'white',
                                highlight: {
                                    background: 'rgba(255,255,0,1.0)',
                                    border: 'white'
                                }
                            }
                        },
                        SC: {
                            color: {
                                background: 'rgba(132,132,132,0.8)',
                                border: 'lightgrey',
                                highlight: {
                                    background: 'rgba(132,132,132,1.0)',
                                    border: 'lightgrey'
                                }
                            }
                        },
                        IX: {
                            color: {
                                background: 'rgba(255,0,64,0.8)',
                                border: 'pink',
                                highlight: {
                                    background: 'rgba(255,0,64,1.0)',
                                    border: 'pink'
                                }
                            }
                        },
                        other: {
                            color: {
                                background: 'rgba(8,138,8,0.8)',
                                border: 'limegreen',
                                highlight: {
                                    background: 'rgba(8,138,8,1.0)',
                                    border: 'limegreen'
                                }
                            }
                        },
                        tier1: {
                            color: {
                                background: 'rgba(255,127,80,0.8)',
                                border: 'orange',
                                highlight: {
                                    background: 'rgba(255,127,80,1.0)',
                                    border: 'orange'
                                }
                            }
                        }
                    },
                    interaction: {
                        navigationButtons: true,
                        zoomView: true,
                        dragNodes: false,
                        hideEdgesOnDrag: true,
                        keyboard: true
                    }
                };

                var data = {nodes:vis_nodes, edges: vis_edges}
                network = new vis.Network(container, data, options);
                allNodes = vis_nodes.get({returnType: 'Object'});
                allEdges = vis_edges.get({returnType: 'Object'});

                // Handle the neighbour highlighting
                network.on('click', neighbourHighlight);

                // Fit the network to the viewport
                network.fit();

                // Display the metadata
                document.getElementById('metadata_text').innerHTML = "Updated on: " +
                metadata['updated'] + "<br/>" +
                "Number of traceroutes: " + metadata['tracert_num'] + "<br/>" +
                "Number of probes: " + metadata['probes_num'] + "<br/>" +
                "Raw <a href=\"" + datafile + "\">data</a>";

                // Add references in the legend to the country name
                document.getElementById('PriCountry').innerHTML = metadata['PriCountry'];
                document.getElementById('SecCountry').innerHTML = metadata['SecCountry'];

                // Change the template to add the country
                cc_labels = document.getElementsByClassName('country');
                for (cc_idx in cc_labels) {
                    cc_labels[cc_idx].innerHTML = metadata['PriCountry'];
                }

                // Enable the node search
                $('#node-search').autocomplete({
                    source: node_names,
                    change: function(event, ui) {
                        $('#node-search').val('');
                        return false;
                    },
                    select: function(event, ui) {
                        network.fit({
                            nodes: [ui.item.value],
                            animation: {
                                duration: 200
                            }
                        });
                        // Set the menu with the label of the node selected
                        $('#node-search').val(ui.item.label);
                        // Clear any highlight if present
                        neighbourHighlight({nodes: [], edges: []});
                        // Highlight the selected node
                        neighbourHighlight({nodes: [ui.item.value],
                                            network: network});
                        this.value = '';
                        return false;
                    }
                });

                // Enable the path search
                for (src in path_sel) {
                    $('#path_s').append($('<option>').attr('value', src).text(src));
                }
                $("#path_s").change(function() {
                    src = $(this).val();
                    // Clear any existing option
                    $('#path_e').find('option').remove().end();
                    // Add a placeholder
                    $('#path_e').append($('<option>')
                        .attr('disabled', 'disabled')
                        .attr('selected', 'selected')
                        .text('Pick End'));
                    for (var dst in path_sel[src]) {
                        // Add the corresponding options
                        $('#path_e').append($('<option>').attr('value', dst).text(dst));
                    }
                    // Add the event handler
                    $('#path_e').change(function() {
                        src = $('#path_s').val();
                        dst = $(this).val();
                        p_nodes = path_sel[src][dst];
                        p_edges = [];
                        // console.log("From: " + src + " To: " + dst);
                        // Find the right edges
                        for (i = 0; i < p_nodes.length-1; i++) {
                            // console.log("Node: " + p_nodes[i]);
                            // console.log("Next Node: " + p_nodes[i+1]);
                            // Find all the edges from this node
                            c_edges = network.getConnectedEdges(p_nodes[i]);
                            // console.log("Edges: " + c_edges);
                            for (j = 0; j < c_edges.length; j++) {
                                c_nodes = network.getConnectedNodes(c_edges[j])
                                // console.log("Edge " + c_edges[j] + " connects " + c_nodes);
                                if (c_nodes.indexOf(p_nodes[i+1]) != -1) {
                                    // console.log("Nodes: " + c_nodes + " Edge: " + c_edges[j]);
                                    p_edges.push(c_edges[j]);
                                    break;
                                }
                            }

                        }
                        // Highlight the nodes and edges in the path
                        pathHighlight({
                            nodes: p_nodes,
                            edges: p_edges,
                            network: network});
                    });
                });
            }

            function pathHighlight(params) {
                // Get a sequence of nodes and edges to highlight
                if (params.nodes.length > 0) {
                    highlightActive = true;

                    // mark all nodes as hard to read.
                    for (var nodeId in allNodes) {
                        allNodes[nodeId].color = 'rgba(100,100,100,0.5)';
                        if (allNodes[nodeId].hiddenLabel === undefined) {
                            allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
                            allNodes[nodeId].label = undefined;
                        }
                    }

                    // Give the provided nodes their colors back
                    for (i = 0; i < params.nodes.length; i++) {
                        var node_idx = params.nodes[i];
                        allNodes[node_idx].color = undefined;
                        if (allNodes[node_idx].hiddenLabel !== undefined) {
                            allNodes[node_idx].label = allNodes[node_idx].hiddenLabel;
                            allNodes[node_idx].hiddenLabel = undefined;
                        }
                    }

                    // Highlight the nodes
                    if (params.hasOwnProperty('network')) {
                        params.network.selectNodes(params.nodes, false);
                        params.network.selectEdges(params.edges);
                    }
                }
                else if (highlightActive === true) {
                    // reset all nodes
                    for (var nodeId in allNodes) {
                        allNodes[nodeId].color = undefined;
                        if (allNodes[nodeId].hiddenLabel !== undefined) {
                          allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
                          allNodes[nodeId].hiddenLabel = undefined;
                        }
                    }
                    highlightActive = false
                }

                // transform the object into an array
                var updateArray = [];
                for (nodeId in allNodes) {
                  if (allNodes.hasOwnProperty(nodeId)) {
                    updateArray.push(allNodes[nodeId]);
                  }
                }
                vis_nodes.update(updateArray);
            }


            function neighbourHighlight(params) {
                // Click on an edge
                if (params.nodes.length == 0 && params.edges.length > 0) {
                    var selectedEdge = params.edges[0]
                    hl_edge = true;
                    if (allEdges[selectedEdge].hasOwnProperty('pairs')) {
                        $('#info_window').html("<b>IP addresses for this edge:<b/><br/>" +
                            allEdges[selectedEdge]['pairs'].join("<br/>"));
                    }
                }
                // Click on a node
                else if (params.nodes.length > 0) {
                  highlightActive = true;
                  var i,j;
                  var selectedNode = params.nodes[0];
                  var degrees = 1;

                  // mark all nodes as hard to read.
                  for (var nodeId in allNodes) {
                    allNodes[nodeId].color = 'rgba(100,100,100,0.5)';
                    if (allNodes[nodeId].hiddenLabel === undefined) {
                      allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
                      allNodes[nodeId].label = undefined;
                    }
                  }

                  var connectedNodes = network.getConnectedNodes(selectedNode);
                  var allConnectedNodes = [];

                  // get all connected nodes to a degree
                  for (i = 1; i < degrees; i++) {
                    for (j = 0; j < connectedNodes.length; j++) {
                      allConnectedNodes = allConnectedNodes.concat(network.getConnectedNodes(connectedNodes[j]));
                    }
                  }

                  // all first degree nodes get their own color and their label back
                  for (i = 0; i < connectedNodes.length; i++) {
                    allNodes[connectedNodes[i]].color = undefined;
                    if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
                      allNodes[connectedNodes[i]].label = allNodes[connectedNodes[i]].hiddenLabel;
                      allNodes[connectedNodes[i]].hiddenLabel = undefined;
                    }
                  }

                  // the main node gets its own color and its label back.
                  allNodes[selectedNode].color = undefined;
                  if (allNodes[selectedNode].hiddenLabel !== undefined) {
                    allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
                    allNodes[selectedNode].hiddenLabel = undefined;
                  }

                  if (params.hasOwnProperty('network')) {
                      params.network.selectNodes([selectedNode], true);
                  }

                  // Provide some information about the node
                  var thisNode = allNodes[selectedNode];
                  document.getElementById('info_window').innerHTML = "<b>Name:</b> " + thisNode.label + "<br/>" +
                        "<b>Long Name:</b> " + thisNode.descr + "<br/>" +
                        "<b>ASN:</b> " + thisNode.asn + "<br/>" +
                        "<b># Peers:</b> " + thisNode.value + "<br/>" +
                        "<b>Country:</b> " + thisNode.country;

                }
                else if (highlightActive === true) {
                  // reset all nodes
                  for (var nodeId in allNodes) {
                    allNodes[nodeId].color = undefined;
                    if (allNodes[nodeId].hiddenLabel !== undefined) {
                      allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
                      allNodes[nodeId].hiddenLabel = undefined;
                    }
                  }
                  highlightActive = false
                }
                else if (hl_edge === true) {
                    document.getElementById('info_window').innerHTML = '';
                }

                // transform the object into an array
                var updateArray = [];
                for (nodeId in allNodes) {
                  if (allNodes.hasOwnProperty(nodeId)) {
                    updateArray.push(allNodes[nodeId]);
                  }
                }
                vis_nodes.update(updateArray);
            }
        });


    </script>
</body>
</html>