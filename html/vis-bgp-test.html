<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>NZ IP Topology Map</title>
    <style type="text/css">
    html, body {
        width: 100%;
        height: 100%;
    }
    #ipvis {
      height: 85%;
      width: 100%;
      background: black;
        margin-left: 20%;
    }
    #legend {
      float: left;
      width: 20%;
        min-height: 85%;
        position: relative;
      background: black;
      color: white;
      font-size: 8;
      font-family: 'Source Sans Pro', Helvetica, sans-serif;
    }
    #console {
        float: left;
        background: black;
        color: white;
        font-size: 8;
        min-height: 15%;
        width: 100%;
    }
    #brand-title {
        font-weight: 200;
        font-size: 20px;
        text-align: left;
        font-family: 'Source Sans Pro', Helvetica, sans-serif;
    }
    #metadata {
        position: absolute;
        left: 0;
        bottom: 0;
    }
    </style>
</head>
<body>
    <div id="legend">
        <span id="brand-title">NZ IP Topology Map</span>
        <image height="80px" src="/images/NZRS_Logo_white.png"/>
        <ul>
            <li>Topology derived from hundreds of ICMP traceroutes, originated from the <a href="https://atlas.ripe.net">RIPE ATLAS</a> probes located in NZ
                <ul>
                    <li>To any other RIPE ATLAS probes in NZ
                    <li>To randomly selected IP addresses in NZ</li>
                    <li>To 50 random websites present in the Alexa Top 250 sites in NZ</li>
                </ul>
            <li>IP addresses mapped to ASN using MaxMind GeoIP database. AS Path derived from IP Path using custom code.</li>
            <li>Country and names for each AS fetched from Team Cymru <a href="http://www.team-cymru.org/IP-ASN-mapping.html">database</a></li>
        </ul>
        <span id="metadata"></span>
    </div>
    <div id="ipvis"></div>
    <div id="console">Information:<br/><span id="edge_info"/></div>

    <script src="/scripts/vis.min.js"></script>
    <script src="/misc/data/vis-bgp-graph.js"></script>

    <script type="text/javascript">
        var network;
        var highlightActive = false;
        var hl_edge = false;
        var datafile = '/misc/data/vis-bgp-graph.json';
        // Data comes from the vis-bgp-graph.js file
        var vis_nodes = new vis.DataSet(nodes);
        var vis_edges = new vis.DataSet(edges);

        function redrawAll() {
            var container = document.getElementById('ipvis');
            var options = {
                autoResize: true,
                width: '100%',
                height: '100%',
                interaction: {

                },
                layout: {
                    randomSeed: 8
                },
                nodes: {
                    shape: 'dot',
                    size: 20,
                    physics: true,
                    borderWidth: 1,
                    font: {
                        color: 'white',
                        size: 10
                    }
                },
                edges: {
                    smooth: {
                        enabled: false
                    },
                    width: 2,
                    color: {
                        color: 'rgba(255,255,255,0.3)'
                    }
                },
                groups: {
                    PC: {
                        color: {
                            background: 'rgba(255,255,0,0.8)',
                            border: 'white',
                            highlight: {
                                background: 'rgba(255,255,0,1.0)',
                                border: 'white'
                            }
                        }
                    },
                    SC: {
                        color: {
                            background: 'rgba(132,132,132,0.8)',
                            border: 'lightgrey',
                            highlight: {
                                background: 'rgba(132,132,132,1.0)',
                                border: 'lightgrey'
                            }
                        }
                    },
                    IX: {
                        color: {
                            background: 'rgba(255,0,64,0.8)',
                            border: 'pink',
                            highlight: {
                                background: 'rgba(255,0,64,1.0)',
                                border: 'pink'
                            }
                        }
                    },
                    other: {
                        color: {
                            background: 'rgba(8,138,8,0.8)',
                            border: 'limegreen',
                            highlight: {
                                background: 'rgba(8,138,8,1.0)',
                                border: 'limegreen'
                            }
                        }
                    }
                },
                interaction: {
                    navigationButtons: true,
                    zoomView: true
                },
                physics: {
                    "stabilization": false,
                    "barnesHut": {
                        "gravitationalConstant": -17500,
                        "centralGravity": 0.35,
                        "springLength": 220,
                        "springConstant": 0.05,
                        "damping": 0.75,
                        "avoidOverlap": 0.75
                    }
                }
            };

            var data = {nodes:vis_nodes, edges: vis_edges}
            network = new vis.Network(container, data, options);
            allNodes = vis_nodes.get({returnType: 'Object'});
            allEdges = vis_edges.get({returnType: 'Object'});
            // Do this to save the location of nodes in the network once the
            // physics simulation finishes
            network.on('stabilized', function() { network.storePositions(); });
            network.on('click', neighbourHighlight);

            // Display the metadata
            document.getElementById('metadata').innerHTML = "Updated on: " +
            metadata['updated'] + "<br/>" +
            "Number of traceroutes: " + metadata['tracert_num'] + "<br/>" +
            "Number of probes: " + metadata['probes_num'] + "<br/>" +
            "Raw <a href=\"" + datafile + "\">data</a>";
        }

        function neighbourHighlight(params) {
            // Click on an edge
            if (params.nodes.length == 0 && params.edges.length > 0) {
                var selectedEdge = params.edges[0]
                hl_edge = true;
                document.getElementById('edge_info').innerHTML = "<b>IP addresses for this edge:<b/><br/>" +
                    allEdges[selectedEdge]['pairs'].join("<br/>");
            }
            // Click on a node
            else if (params.nodes.length > 0) {
              highlightActive = true;
              var i,j;
              var selectedNode = params.nodes[0];
              var degrees = 1;

              // mark all nodes as hard to read.
              for (var nodeId in allNodes) {
                allNodes[nodeId].color = 'rgba(100,100,100,0.5)';
                if (allNodes[nodeId].hiddenLabel === undefined) {
                  allNodes[nodeId].hiddenLabel = allNodes[nodeId].label;
                  allNodes[nodeId].label = undefined;
                }
              }

              var connectedNodes = network.getConnectedNodes(selectedNode);
              var allConnectedNodes = [];

              // get all connected nodes to a degree
              for (i = 1; i < degrees; i++) {
                for (j = 0; j < connectedNodes.length; j++) {
                  allConnectedNodes = allConnectedNodes.concat(network.getConnectedNodes(connectedNodes[j]));
                }
              }

              // all first degree nodes get their own color and their label back
              for (i = 0; i < connectedNodes.length; i++) {
                allNodes[connectedNodes[i]].color = undefined;
                if (allNodes[connectedNodes[i]].hiddenLabel !== undefined) {
                  allNodes[connectedNodes[i]].label = allNodes[connectedNodes[i]].hiddenLabel;
                  allNodes[connectedNodes[i]].hiddenLabel = undefined;
                }
              }

              // the main node gets its own color and its label back.
              allNodes[selectedNode].color = undefined;
              if (allNodes[selectedNode].hiddenLabel !== undefined) {
                allNodes[selectedNode].label = allNodes[selectedNode].hiddenLabel;
                allNodes[selectedNode].hiddenLabel = undefined;
              }
            }
            else if (highlightActive === true) {
              // reset all nodes
              for (var nodeId in allNodes) {
                allNodes[nodeId].color = undefined;
                if (allNodes[nodeId].hiddenLabel !== undefined) {
                  allNodes[nodeId].label = allNodes[nodeId].hiddenLabel;
                  allNodes[nodeId].hiddenLabel = undefined;
                }
              }
              highlightActive = false
            }
            else if (hl_edge === true) {
                document.getElementById('edge_info').innerHTML = '';
            }

            // transform the object into an array
            var updateArray = [];
            for (nodeId in allNodes) {
              if (allNodes.hasOwnProperty(nodeId)) {
                updateArray.push(allNodes[nodeId]);
              }
            }
            vis_nodes.update(updateArray);
        }

        redrawAll()
    </script>
</body>
</html>
